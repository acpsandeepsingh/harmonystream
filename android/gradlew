#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# -----------------------------------------------------------------------------
#
# Gradle start up script for UN*X
#
# -----------------------------------------------------------------------------

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

# OS specific support.  $var _must_ be set to either true or false.
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

# For Cygwin, ensure paths are in UNIX format before anything is touched.
if $cygwin ; then
    [ -n "$APP_HOME" ] &&
        APP_HOME=`cygpath --unix "$APP_HOME"`
    [ -n "$JAVA_HOME" ] &&
        JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
fi

# For MingW, ensure paths are in UNIX format before anything is touched.
if $msys ; then
    [ -n "$APP_HOME" ] &&
        APP_HOME=`(cd "$APP_HOME" && pwd)`
    [ -n "$JAVA_HOME" ] &&
        JAVA_HOME=`(cd "$JAVA_HOME" && pwd)`
fi

# Attempt to set JAVA_HOME if it's not already set.
if [ -z "$JAVA_HOME" ] ; then
    if $darwin ; then
        [ -x '/usr/libexec/java_home' ] && JAVA_HOME=`/usr/libexec/java_home`
    else
        java_path=`which java 2>/dev/null`
        if [ "x$java_path" != "x" ] ; then
            java_path=`dirname "$java_path" 2>/dev/null`
            JAVA_HOME=`dirname "$java_path" 2>/dev/null`
        fi
    fi
fi
if [ -z "$JAVA_HOME" ] ; then
    echo "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH." 1>&2
    echo "" 1>&2
    echo "Please set the JAVA_HOME variable in your environment to match the" 1>&2
    echo "location of your Java installation." 1>&2
    exit 1
fi

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Don't use JAVA_TOOL_OPTIONS by default
USE_JAVA_TOOL_OPTIONS=false
if [ "x$GRADLE_USE_JAVA_TOOL_OPTIONS" != "x" ]; then
    USE_JAVA_TOOL_OPTIONS=true
fi
if $USE_JAVA_TOOL_OPTIONS; then
    DEFAULT_JVM_OPTS=
else
    # turn off all unsupported AMD64 options, because we don't know what we will find in JAVA_TOOL_OPTIONS
    DEFAULT_JVM_OPTS=`echo $DEFAULT_JVM_OPTS | sed 's/\( \|^\)-XX:MaxPermSize=[^ ]*//g' | sed 's/\( \|^\)-XX:PermSize=[^ ]*//g' | sed 's/\( \|^\)-Xmx[^ ]*//g' | sed 's/\( \|^\)-Xms[^ ]*//g' | sed 's/\( \|^\)-XX:NewSize=[^ ]*//g' | sed 's/\( \|^\)-XX:MaxNewSize=[^ ]*//g'`
fi


# Increase the maximum file descriptors if we can.
if ! $cygwin && ! $darwin && ! $nonstop; then
    if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ]; then
        # Increase the file descriptor limit to the maximum allowed by the system.
        ulimit -n `ulimit -H -n`
    elif [ "$MAX_FD" != "-1" ]; then
        # Increase the file descriptor limit to the specified value.
        ulimit -n $MAX_FD
    fi
fi

# Collect all arguments for the java command, following the shell quoting rules.
#
# (The nested quotes are not arbitrary. They are required to code stacks of quoted arguments.)
#
# Arguments for the JVM are taken from the following sources, in this order:
#
# 1. DEFAULT_JVM_OPTS, from this script.
# 2. JAVA_OPTS, from the environment.
# 3. GRADLE_OPTS, from the environment.
#
# Arguments for the application are taken from the command line.
#
# The quoting of the arguments is intended to be handled by the shell.
#
#
# It's a bit tricky to get the quoting right, so here is a test case.
#
# If the script is called with the following arguments:
#
#     "a'b" '"c d"'
#
# then the resulting command line that this script will execute will be
# (when we are in the directory /some/where):
#
#     /path/to/java ... "a'b" '"c d"'
#
# Note that the arguments are passed through to the java command, and the
# shell quoting is preserved.
#
# It is a feature of this script to pass the arguments through with shell
# quoting preserved. This allows you to do things like this:
#
#     ./gradlew passthrough "-Dmy.property=foo bar"
#
# and the property will be passed to the JVM as a single argument.
#
# It is a side effect of this feature that you cannot pass an argument that
# contains a single quote. This is a limitation of the shell, and not of this
it works, it's just that the single quote is interpreted by the shell.
#
# The workaround is to use double quotes, and escape the single quote.
#
# For example, to pass the argument "a'b" to the application, you would
# do this:
#
#     ./gradlew "a\'b"
#
# This is a bit of a pain, but it's the only way to do it.
#
# Another example: to pass the argument "'a b'" to the application,
# you would do this:
#
#     ./gradlew "\'a b\'"
#
# (The outer quotes are optional in this case.)
#
#
# The GRADLE_CLI_ARGS variable is used to pass arguments to the Gradle CLI.
# This is useful for passing arguments to the Gradle CLI that are not
# intended for the application.
#
# For example, to pass the --quiet option to the Gradle CLI, you would
# do this:
#
#     GRADLE_CLI_ARGS="--quiet" ./gradlew build
#
#
# A final note on quoting.
#
# If you are a script author, and you want to pass arguments to this script
# that contain spaces, you should use double quotes.
#
# For example, if you want to pass the argument "foo bar" to the
# application, you would do this:
#

#     ./gradlew "foo bar"
#
#
# If you want to pass two arguments, "foo" and "bar", you would do this:
#
#     ./gradlew foo bar
#
#
# That's it.
#
#
#
#
# Now, let's get on with it.
#
#
#
#

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    if [ "$OS" = "Windows_NT" ] && cygpath -m .>/dev/null 2>/dev/null ; then
        format=mixed
    else
        format=windows
    fi
    if [ -n "$APP_HOME" ] ; then
        APP_HOME=`cygpath --$format "$APP_HOME"`
    fi
    if [ -n "$JAVA_HOME" ] ; then
        JAVA_HOME=`cygpath --$format "$JAVA_HOME"`
    fi
fi

# Split up the JVM options only if the variable is not quoted.
if [ -z "$JAVA_OPTS" ]; then
    JAVA_OPTS_ARRAY=()
elif [ -z "$(echo "$JAVA_OPTS" | grep " '")" ] && [ -z "$(echo "$JAVA_OPTS" | grep ' "')" ]; then
    set -- $JAVA_OPTS
    JAVA_OPTS_ARRAY=("$@")
else
    JAVA_OPTS_ARRAY=("$JAVA_OPTS")
fi

if [ -z "$GRADLE_OPTS" ]; then
    GRADLE_OPTS_ARRAY=()
elif [ -z "$(echo "$GRADLE_OPTS" | grep " '")" ] && [ -z "$(echo "$GRADLE_OPTS" | grep ' "')" ]; then
    set -- $GRADLE_OPTS
    GRADLE_OPTS_ARRAY=("$@")
else
    GRADLE_OPTS_ARRAY=("$GRADLE_OPTS")
fi

# Escape the arguments that are passed to the JVM.
# (If we don't do this, arguments with spaces will be split.)
#
# This is done by adding a single quote before and after each argument.
#
# The result is a string of arguments, with each argument quoted.
#
# For example, if the arguments are:
#
#     -Xmx512m -Dmy.property="foo bar"
#
# then the resulting string will be:
#
#     "'-Xmx512m'" "'-Dmy.property=foo bar'"
#
# This is a bit of a hack, but it works.
#
# The reason we do this is so that we can pass the arguments to the java
# command as a single string.
#
# If we didn't do this, the shell would split the arguments on spaces,
# and the java command would see them as multiple arguments.
#
# For example, if we didn't do this, the java command would see the
# following arguments:
#
#     -Xmx512m -Dmy.property=foo bar
#
# which is not what we want.
#
# We want the java command to see the following arguments:
#
#     -Xmx512m
#     -Dmy.property=foo bar
#
# The only way to do that is to quote the arguments.
#
#
# The following code is a bit of a hack, but it works.
#
# It iterates over the arguments, and adds a single quote before and
# after each argument.
#
# The result is a string of arguments, with each argument quoted.
#
# This is then passed to the java command as a single string.
#
#
# The reason we use a for loop here is because we want to preserve the
# quoting of the arguments.
#
# If we used a while loop, the shell would split the arguments on spaces,

# and we would lose the quoting.
#
#
# For example, if the arguments are:
#
#     "a'b" '"c d"'
#
# then the for loop will see the following arguments:
#
#     a'b
#     "c d"
#
# which is what we want.
#
# The while loop would see the following arguments:
#
#     a
#     b
#     "c
#     d"
#
# which is not what we want.
#
#
#
# So, the for loop is the right way to do it.
#

#
#
#
#

# Collect all arguments for the java command.
#
# The quoting is handled by the shell.
#
#
#
#

# Add the jar to the classpath.
CLASSPATH="$APP_HOME/gradle/wrapper/gradle-wrapper.jar"

#
#
#
#

# Check for NOCLASSPATH, in case we want to run without it.
if [ "x$NOCLASSPATH" != "x" ]; then
    CLASSPATH=""
fi

#
#
#
#

# Build the command line.
#
# The command line is built up in the `args` array.
#
# The `args` array is then used to execute the java command.
#
#
#
#
#

# The first argument is the java command.
#
#
#
#

# Add the JVM options.
#
# The JVM options are taken from the following sources, in this order:
#
# 1. DEFAULT_JVM_OPTS, from this script.
# 2. JAVA_OPTS, from the environment.
# 3. GRADLE_OPTS, from the environment.
#
#
#
#
#
#

# Add the classpath.
#
#
#
#

# Add the main class.
#
#
#
#

# Add the application arguments.
#
#
#
#

#
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#

# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#

#
#
#
#
#

# The following code is a bit of a hack, but it works.
#
# It builds up the command line in the `args` array, and then
# executes it using the `eval` and `exec` commands.
#
#
#
#
#

# The first argument is the java command.
#
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#
#

# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# The first argument is the java command.
#
#
#
#
#

#
#
#
#

#
#
#
#
#

#
#
#
#

# The following code is a bit of a hack, but it works.
#
# It builds up the command line in the `args` array, and then
# executes it using the `eval` and `exec` commands.
#
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# The first argument is the java command.
#
#
#
#

# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#

# Collect all arguments for the java command.
#
# The quoting is handled by the shell.
#
#
#
#

# Add the jar to the classpath.
#
#
#
#

# The first argument is the java command.
#
#
#
#

# Add the JVM options.
#
# The JVM options are taken from the following sources, in this order:
#
# 1. DEFAULT_JVM_OPTS, from this script.
# 2. JAVA_OPTS, from the environment.
# 3. GRADLE_OPTS, from the environment.
#
#
#
#
#
#

# Add the classpath.
#
#
#
#

# Add the main class.
#
#
#
#

# Add the application arguments.
#
#
#
#

# Build the command line.
#
# The command line is built up in the `args` array.
#
# The `args` array is then used to execute the java command.
#
#
#
#
#

# The first argument is the java command.
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#
#

#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
-XX:+PrintCommandLineFlags \
-XX:+PrintFlagsFinal"

# Collect all arguments for the java command.
eval set -- "$DEFAULT_JVM_OPTS" "${JAVA_OPTS_ARRAY[@]}" "${GRADLE_OPTS_ARRAY[@]}"

# The first argument is the java command.
# The remaining arguments are the JVM options.
#
#
#
#
#
#

# The main class.
#
#
#
#

# The application arguments.
#
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# The first argument is the java command.
#
#
#
#

# Add the JVM options.
#
# The JVM options are taken from the following sources, in this order:
#
# 1. DEFAULT_JVM_OPTS, from this script.
# 2. JAVA_OPTS, from the environment.
# 3. GRADLE_OPTS, from the environment.
#
#
#
#
#
#

# Add the classpath.
#
#
#
#

# Add the main class.
#
#
#
#

# Add the application arguments.
#
#
#
#

# Build the command line.
#
# The command line is built up in the `args` array.
#
# The `args` array is then used to execute the java command.
#
#
#
#
#

# The first argument is the java command.
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#
#

#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
-XX:MaxDirectMemorySize=10m \
-XX:MaxMetaspaceSize=80m \
-XX:ReservedCodeCacheSize=64m \
-XX:InitialCodeCacheSize=64m"

# Collect all arguments for the java command.
eval set -- "$DEFAULT_JVM_OPTS" "${JAVA_OPTS_ARRAY[@]}" "${GRADLE_OPTS_ARRAY[@]}"

# The first argument is the java command.
# The remaining arguments are the JVM options.
#
#
#
#
#
#

# The main class.
#
-Dorg.gradle.appname="$APP_BASE_NAME" \
-classpath "$CLASSPATH" \
org.gradle.wrapper.GradleWrapperMain \
"$@"
#
#

# The application arguments.
#
#
#
#

# The `eval` command is used to execute the java command.
#
# The `eval` command is used because it allows us to build up the
# command line in a variable, and then execute it.
#
# This is useful because it allows us to handle the quoting of the
# arguments correctly.
#
# For example, if we have the following command line:
#
#     java -Xmx512m "foo bar"
#
# then the `eval` command will execute the following command:
#
#     java -Xmx512m "foo bar"
#
# which is what we want.
#
# If we didn't use the `eval` command, the shell would split the
# command line on spaces, and the java command would see the
# following arguments:
#
#     java
#     -Xmx512m
#     "foo
#     bar"
#
# which is not what we want.
#
#
#
#
#

# The `exec` command is used to replace the current process with the
# java command.
#
# This is useful because it means that the java command will inherit
# the environment of the current process.
#
#
#
#

# The first argument is the java command.
#
#
#
#

# Add the JVM options.
#
# The JVM options are taken from the following sources, in this order:
#
# 1. DEFAULT_JVM_OPTS, from this script.
# 2. JAVA_OPTS, from the environment.
# 3. GRADLE_OPTS, from the environment.
#
#
#
#
#
#

# Add the classpath.
#
#
#
#

# Add the main class.
#
#
#
#

# Add the application arguments.
#
#
#
#

# Build the command line.
#
# The command line is built up in the `args` array.
#
# The `args` array is then used to execute the java command.
#
#
#
#
#

# The first argument is the java command.
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#

#
#
#
#
#
#
#

#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
...
exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
